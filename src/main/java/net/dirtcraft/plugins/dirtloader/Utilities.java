package net.dirtcraft.plugins.dirtloader;

import org.bukkit.ChatColor;
import org.bukkit.command.CommandSender;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.logging.Level;

public class Utilities {
	public static FileConfiguration config;
	private static File configFile = new File(DirtLoader.getPlugin().getDataFolder(), "config.yml");

	static {
		config = YamlConfiguration.loadConfiguration(new File(DirtLoader.getPlugin().getDataFolder(), "config.yml"));
	}

	public static void createConfigFile() {
		// ------------------------- Config File -------------------------
		config.options().header(
				"DirtLoader configuration file."
						+ "\nThis file is automatically generated and contains configurable options."
						+ "\n!! Do not edit this file unless you know what you are doing !!"
						+ "\n\ngeneral:"
						+ "\n  - online: The amount of online chunks new players get. (default: 3)"
						+ "\n  - offline: The amount of offline chunks new players get. (default: 0)"
						+ "\n  - play-success-sound: Whether or not to play a sound when a player loads a chunk. (default: true)"
						+ "\n  - success-sound: The sound to be played. (default: minecraft:entity.experience_orb.pickup)"
						+ "\n  - play-failure-sound: Whether or not to play a sound when a player fails to load a chunk. (default: true)"
						+ "\n  - failure-sound: The sound to be played. (default: minecraft:entity.creeper.death)"
						+ "\n  - player-add-message: Whether or not to send a message to the player when chunks are added to their balance. (default: true)"
						+ "\n  - player-remove-message: Whether or not to send a message to the player when chunks are removed from their balance. (default: true)"
						+ "\n  - max-list-entries-per-page: The maximum amount of entries to be shown per page in the /dl list command. (default: 5)"
						+ "\n  - teleport-command: The tp command that should be used when teleporting to a chunk. Players need permission to execute this command! (default: /minecraft:tp)"
						+ "\n\noffline:"
						+ "\n  -duration: How long (in hours) does the offline chunk stay loaded after the player left. (default: 12)"
						+ "\n\ndebug-messages: Whether or not to show debug messages. (default: true)"
						+ "\n"
		);
		config.addDefault("general.online", 3);
		config.addDefault("general.offline", 0);
		config.addDefault("general.play-success-sound", true);
		config.addDefault("general.success-sound", "minecraft:entity.experience_orb.pickup");
		config.addDefault("general.play-failure-sound", true);
		config.addDefault("general.failure-sound", "minecraft:entity.creeper.death");
		config.addDefault("general.player-add-message", true);
		config.addDefault("general.player-remove-message", true);
		config.addDefault("general.max-list-entries-per-page", 5);
		config.addDefault("general.teleport-command", "/minecraft:tp");
		config.addDefault("offline.duration", 12);
		config.addDefault("debug-messages", true);
		config.options().copyDefaults(true);
		config.options().copyHeader(true);
		saveConfigFile();
	}

	public static void generatePlayerFile(Player player) {
		File file = new File(DirtLoader.getPlugin().getDataFolder() + "/playerdata", player.getUniqueId() + ".yml");
		if (!file.exists()) {
			if (config.getBoolean("debug-messages")) {
				DirtLoader.getPlugin().getLogger().log(Level.INFO, "Creating player file for " + player.getName());
			}
			final FileConfiguration playerFile = YamlConfiguration.loadConfiguration(file);
			playerFile.addDefault("name", player.getName());
			playerFile.addDefault("available.online", config.get("general.online"));
			playerFile.addDefault("available.offline", config.get("general.offline"));
			playerFile.addDefault("original.online", config.get("general.online"));
			playerFile.addDefault("original.offline", config.get("general.offline"));
			playerFile.addDefault("used.online", 0);
			playerFile.addDefault("used.offline", 0);
			playerFile.addDefault("chunks", new ArrayList<String>());
			playerFile.options().copyDefaults(true);

			savePlayerFile(playerFile, file, player);
		}
	}

	public static FileConfiguration getPlayerFile(Player player) {
		File file = new File(DirtLoader.getPlugin().getDataFolder() + "/playerdata", player.getUniqueId() + ".yml");
		if (!file.exists()) {
			generatePlayerFile(player);
		}
		return YamlConfiguration.loadConfiguration(file);
	}

	public static void addChunksToPlayer(Player player, String type, int amount, CommandSender sender) {
		File file = new File(DirtLoader.getPlugin().getDataFolder() + "/playerdata", player.getUniqueId() + ".yml");
		if (file.exists()) {
			FileConfiguration playerFile = YamlConfiguration.loadConfiguration(file);
			if (type.equals("online")) {
				playerFile.set("available.online", playerFile.getInt("available.online") + amount);
			} else {
				playerFile.set("available.offline", playerFile.getInt("available.offline") + amount);
			}

			sender.sendMessage(Strings.PREFIX + ChatColor.GRAY + "Successfully " + ChatColor.GREEN + "added " + ChatColor.GRAY + amount + " " + ChatColor.DARK_AQUA + type + ChatColor.GRAY + " chunk" + (amount > 1 ? "s" : "") + " to " + player.getName() + ".");
			savePlayerFile(playerFile, file, player);
			if (config.getBoolean("general.player-add-message")) {
				player.sendMessage(Strings.PREFIX + ChatColor.GRAY + "You have been given " + ChatColor.GREEN + amount + " " + ChatColor.DARK_AQUA + type + ChatColor.GRAY + " chunk" + (amount > 1 ? "s" : "") + ".");
			}
		}
	}

	public static void removeChunksFromPlayer(Player player, String type, int amount, CommandSender sender) {
		File file = new File(DirtLoader.getPlugin().getDataFolder() + "/playerdata", player.getUniqueId() + ".yml");
		if (file.exists()) {
			FileConfiguration playerFile = YamlConfiguration.loadConfiguration(file);
			if (type.equals("online")) {
				if (playerFile.getInt("available.online") == 0) {
					sender.sendMessage(Strings.CANT_REMOVE_MORE_CHUNKS);
					return;
				}
				playerFile.set("available.online", playerFile.getInt("available.online") - amount);
			} else {
				if (playerFile.getInt("available.offline") == 0) {
					sender.sendMessage(Strings.CANT_REMOVE_MORE_CHUNKS);
					return;
				}
				playerFile.set("available.offline", playerFile.getInt("available.offline") - amount);
			}

			sender.sendMessage(Strings.PREFIX + ChatColor.GRAY + "Successfully " + ChatColor.RED + "removed " + ChatColor.GRAY + amount + " " + ChatColor.DARK_AQUA + type + ChatColor.GRAY + " chunk" + (amount > 1 ? "s" : "") + " from " + player.getName() + ".");
			savePlayerFile(playerFile, file, player);
			if (config.getBoolean("general.player-remove-message")) {
				player.sendMessage(Strings.PREFIX + ChatColor.RED + amount + " " + ChatColor.DARK_AQUA + type + ChatColor.GRAY + " chunk" + (amount > 1 ? "s" : "") + " have been removed.");
			}
		}
	}

	public static void saveChunkToPlayer(Player player, String world, int chunkX, int chunkY, String type) {
		File file = new File(DirtLoader.getPlugin().getDataFolder() + "/playerdata", player.getUniqueId() + ".yml");
		FileConfiguration playerFile = YamlConfiguration.loadConfiguration(file);
		List<String> chunks = playerFile.getStringList("chunks");
		String timeStamp = new SimpleDateFormat("dd.MM.yyyy_HH:mm:ss").format(Calendar.getInstance().getTime());

		if (playerFile.getInt("used." + type) >= playerFile.getInt("available." + type)) {
			if (config.getBoolean("debug-messages")) {
				DirtLoader.getPlugin().getLogger().log(Level.INFO, "Player " + player.getName() + " has reached their limit of " + type + " chunks!");
			}
			player.sendMessage(Strings.NOT_ENOUGH_LOADERS);
			playFailureSound(player);
			return;
		}

		for (String chunk : chunks) {
			if (chunk.contains(world + "#" + chunkX + "#" + chunkY)) {
				player.sendMessage(Strings.ALREADY_LOADED);
				playFailureSound(player);
				return;
			}
		}

		chunks.add(world + "#" + chunkX + "#" + chunkY + "#" + type + "#" + timeStamp);
		playerFile.set("chunks", chunks);
		int used = playerFile.getInt("used." + type);
		playerFile.set("used." + type, used + 1);
		savePlayerFile(playerFile, file, player);

		player.sendMessage(Strings.PREFIX + ChatColor.GREEN + "Successfully created chunkloader!");
		playSuccessSound(player);
	}

	public static void unloadChunkOfPlayer(CommandSender sender, Player player, String chunk) {
		File file = new File(DirtLoader.getPlugin().getDataFolder() + "/playerdata", player.getUniqueId() + ".yml");
		if (file.exists()) {
			FileConfiguration playerFile = YamlConfiguration.loadConfiguration(file);
			List<String> chunks = playerFile.getStringList("chunks");
			boolean chunkFound = false;
			for (String chunkString : chunks) {
				if (chunkString.equals(chunk)) {
					chunks.remove(chunkString);
					chunkFound = true;
					break;
				}
			}

			if (!chunkFound) {
				return;
			}

			playerFile.set("chunks", chunks);
			int used = playerFile.getInt("used." + chunk.split("#")[3]);
			playerFile.set("used." + chunk.split("#")[3], used - 1);
			savePlayerFile(playerFile, file, player);
			if (!sender.hasPermission(Permissions.UNLOAD_OTHER)) {
				sender.sendMessage(Strings.PREFIX + ChatColor.GRAY + "Successfully " + ChatColor.RED + "unloaded " + ChatColor.GRAY + chunk.split("#")[3] + " chunk ( " + ChatColor.DARK_AQUA + chunk.split("#")[1] + ChatColor.GRAY + " | " + ChatColor.DARK_AQUA + chunk.split("#")[2] + ChatColor.GRAY + " ).");
			} else {
				sender.sendMessage(Strings.PREFIX + ChatColor.GRAY + "Successfully " + ChatColor.RED + "unloaded " + ChatColor.GRAY + chunk.split("#")[3] + " chunk ( " + ChatColor.DARK_AQUA + chunk.split("#")[1] + ChatColor.GRAY + " | " + ChatColor.DARK_AQUA + chunk.split("#")[2] + ChatColor.GRAY + " ) from " + player.getName() + ".");
			}
		}
	}

	private static void savePlayerFile(FileConfiguration playerFile, File file, Player player) {
		try {
			playerFile.save(file);
		} catch (IOException e) {
			DirtLoader.getPlugin().getLogger().log(Level.SEVERE, "Could not save player file for " + player.getName() + "!");
		}
	}

	private static void playSuccessSound(Player player) {
		if (config.getBoolean("general.play-success-sound")) {
			String sound = config.getString("general.success-sound");
			if (sound == null) {
				sound = "minecraft:entity.experience_orb.pickup";
			}
			player.playSound(player.getLocation(), sound, 1, 1);
		}
	}

	private static void playFailureSound(Player player) {
		if (config.getBoolean("general.play-failure-sound")) {
			String sound = config.getString("general.failure-sound");
			if (sound == null) {
				sound = "minecraft:entity.creeper.death";
			}
			player.playSound(player.getLocation(), sound, 1, 1);
		}
	}

	public static void saveConfigFile() {
		if (config == null || configFile == null) {
			return;
		}
		try {
			config.save(configFile);
		} catch (IOException ex) {
			DirtLoader.getPlugin().getLogger().log(Level.SEVERE, "Could not save config file to " + configFile, ex);
		}
	}

	public static void reloadConfigFile() {
		if (configFile == null) {
			configFile = new File(DirtLoader.getPlugin().getDataFolder(), "config.yml");
		}
		config = YamlConfiguration.loadConfiguration(configFile);
	}
}
